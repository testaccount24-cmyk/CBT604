-TITLE SPITBOL TEST PROGRAM #5 -- DEMONSTRATION VERSION OF TREESORT4
-STITL DRIVER
 DEFINE('TREESORT4(DATA,NUMBER_TO_SORT)')
 DEFINE('PRINTER()')
 DATA = ARRAY(24)
         INPUT(.INPUT,,72)
READER J = J + 1
 DATA<J> = TRIM(INPUT)  :S(READER)
 OUTPUT = 'UNSORTED DATA'
 OUTPUT =
 PRINTER()
 TREESORT4(DATA,24)
 OUTPUT =
 OUTPUT = 'SORTED DATA'
 OUTPUT =
 PRINTER() :(END)
*
PRINTER J = 0
PRINTL J = J + 1
 OUTPUT = DATA<J>    :S(PRINTL)F(RETURN)
-STITL ACTUAL TREESORT4 SUBROUTINE
*             TREESORT4
*             ---------
*
*             SORTING ALGORITHM DERIVED FROM FLOYD'S TREESORT3 PUBLISHED
*             IN CACM DEC. 1967 -- THE MODIFICATIONS DEVISED BY R. DEWAR
*             AND L.FISHER REDUCE THE NUMBER OF COMPARES FROM 2NLOGN
*             TO NLOGN -- THIS VERSION CODED IN SNOBOL4 BY R. DEWAR
*
TREESORT4
.             NUMBER_IN_TREE = NUMBER_TO_SORT
              NODE_TO_SIFT = NUMBER_TO_SORT / 2
              RETURN_FROM_SIFT = .SIFT_RETURN_1
SIFT_CALL_1
.             HOLD_LOCATION = DATA<NODE_TO_SIFT> :(SIFT_NODE)
SIFT_RETURN_1
.             NODE_TO_SIFT = GT(NODE_TO_SIFT,1)
.                              NODE_TO_SIFT - 1  :S(SIFT_CALL_1)
SECOND_PHASE
.             RETURN_FROM_SIFT = .SIFT_RETURN_2
SIFT_RETURN_2
.             HOLD_LOCATION = DATA<NUMBER_IN_TREE>
              DATA<NUMBER_IN_TREE> = DATA<1>
              NUMBER_IN_TREE = GT(NUMBER_IN_TREE,1)
.                               NUMBER_IN_TREE - 1
.                                                :S(SIFT_NODE)F(RETURN)
-EJECT
SIFT_NODE
.             FATHER = NODE_TO_SIFT
PULL_UP_LARGER_SON
.             LEFT_SON = FATHER * 2
              LT(LEFT_SON,NUMBER_IN_TREE)        :S(COMPARE_SONS)
              EQ(LEFT_SON,NUMBER_IN_TREE)        :S(LEFT_SON_HIGH)
                                                 :(CHECK_FATHERS)
COMPARE_SONS
.             RIGHT_SON = LEFT_SON + 1
              LGT(DATA<LEFT_SON>,DATA<RIGHT_SON>)
.                                                :S(LEFT_SON_HIGH)
RIGHT_SON_HIGH
.             DATA<FATHER> = DATA<RIGHT_SON>
              FATHER = RIGHT_SON                 :(PULL_UP_LARGER_SON)
LEFT_SON_HIGH
.             DATA<FATHER> = DATA<LEFT_SON>
              FATHER = LEFT_SON                  :(PULL_UP_LARGER_SON)
CHECK_FATHERS
.             HOLE_IN_TREE = FATHER
TEST_NEXT_FATHER
.             FATHER_OF_HOLE = HOLE_IN_TREE / 2
              LT(FATHER_OF_HOLE,NODE_TO_SIFT)    :S(FILL_HOLE)
              LGT(DATA<FATHER_OF_HOLE>,HOLD_LOCATION)
.                                                :S(FILL_HOLE)
              DATA<HOLE_IN_TREE> = DATA<FATHER_OF_HOLE>
              HOLE_IN_TREE = FATHER_OF_HOLE      :(TEST_NEXT_FATHER)
FILL_HOLE
.             DATA<HOLE_IN_TREE> = HOLD_LOCATION
.                                                :($RETURN_FROM_SIFT)
END
SHALL
I
COMPARE
THEE
TO
A
SUMMERS
DAY
THOU
ART
MORE
LOVELY
AND
MORE
TEMPORATE
ROUGH
WINDS
DO
SHAKE
THE
DARLING
BUDS
OF
MAY
